/**
 * https://mp.weixin.qq.com/s/pAzBzSLXwyxPbxGyzWYstQ
 * 
 * 为什么要用 setTimeout 模拟 setInterval?
 */

/**
 * 推入任务队列后的时间不准确
 * 
 * setInterval(fn(), N)
 * 
 * 如上代码的意思是：fn()将会在 N 秒之后被推入任务队列
 * 
 * 所以，在 setInterval 被推入任务队列时，如果在它前面有很多任务或者某个任务等待时间较长比如网络请求等，那么这个定时器的执行时间和我们预定它执行的时间可能并不一致
 */
 const startTime = new Date().getTime();
 let count = 0;
 //耗时任务
 setInterval(function() {
   let i = 0;
   while (i++ < 1000000000);
 }, 0);
 setInterval(function() {
   count++;
   console.log(
     "与原设定的间隔时差了：",
     new Date().getTime() - (startTime + count * 1000),
     "毫秒"
   );
 }, 1000);
// 输出：
// 与原设定的间隔时差了：699 毫秒
// 与原设定的间隔时差了：771 毫秒
// 与原设定的间隔时差了：887 毫秒
// 与原设定的间隔时差了：981 毫秒
// 与原设定的间隔时差了：1142 毫秒
// 与原设定的间隔时差了：1822 毫秒
// 与原设定的间隔时差了：1891 毫秒
// 与原设定的间隔时差了：2001 毫秒
// 与原设定的间隔时差了：2748 毫秒

/**
 * 函数操作耗时过长导致的不准确
 * 
 * 假如定时器里面的代码需要进行大量的计算(耗费时间较长)，或者是 DOM 操作。
 * 这样一来，花的时间就比较长，有可能前一次代码还没有执行完，后一次代码就被添加到队列了。也会到时定时器变得不准确，甚至出现同一时间执行两次的情况。
 * 
 * 最常见的出现的就是，当我们需要使用 ajax 轮询服务器是否有新数据时，必定会有一些人会使用 setInterval ，
 * 然而无论网络状况如何，它都会去一遍又一遍的发送请求，最后的间隔时间可能和原定的时间有很大的出入。
 */


/**
 * setInterval 缺点 与 setTimeout 的不同
 * 
 * 再次强调，定时器指定的时间间隔，表示的是何时将定时器的代码添加到消息队列，而不是何时执行代码。
 * 所以真正何时执行代码的时间是不能保证的，取决于何时被主线程的事件循环取到，并执行。
 * 
 * 如图：【js-timeline.png】，可以看到，setInterval 每隔 100ms 往队列中添加一个事件；100ms 后，添加 T1 定时器代码至队列中，
 * 主线程中还有任务在执行，所以等待，some event 执行结束后执行 T1 定时器代码；又过了 100ms ， 
 * T2 定时器被添加到队列中，主线程还在执行 T1 代码，所以等待；又过了 100ms ，理论上又要往队列里推一个定时器代码，
 * ------------- 但由于此时 T2 还在队列中，所以T3 不会被添加（T3 被跳过），结果就是此时被跳过；-------------
 * 这里我们可以看到，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器的效果。
 * 
 * 综上所述，setInterval 有两个缺点：
 * (1) 使用 setInterval 时，某些间隔会被跳过；
 * (2) 可能多个定时器会连续执行；
 */


/**
 * 综上，你可以这么理解：
 * 
 * 每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，
 * 都要进行一下判断(看上次的任务是否仍在队列中，如果有则不添加，没有则添加)
 * 
 * 因而我们一般用 setTimeout 模拟 setInterval ，来规避掉上面的缺点。
 */


for (var i = 0; i < 5; i++) {
  setTimeout(function() {
    console.log(i);
  }, 1000);
}
// 一秒后立即输出 5 个 5因为 for 循环了五次，所以 setTimeout 被 5 次添加到时间循环中，等待一秒后全部执行。

/**
 * 为什么是一秒后输出了 5 个 5 呢？
 * 
 * 因为 for 是主线程代码，先执行完了，才轮到执行 setTimeout 。
 * 至于输出不是 1 到 5 ，这个涉及到作用域的问题
 */
