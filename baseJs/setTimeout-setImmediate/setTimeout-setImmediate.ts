/**
 * setTimeout和setImmediate到底谁先执行?
 * 
 * 笼统的知道setImmediate比setTimeout(fn, 0)先执行是不够的，因为有些情况下setTimeout(fn, 0)是会比setImmediate先执行的
 */

 /** 
  * Js的异步是如何实现的? 
  * 
  * 所谓的"JS是单线程的"只是指JS的主运行线程只有一个，而不是整个运行环境都是单线程。JS的运行环境主要是浏览器，以大家都很熟悉的Chrome的内核为例，他不仅是多线程的，而且是多进程的
  * 
  * 如图：【浏览器进程.jpg】
  * GUI线程：
  *             GUI线程就是渲染页面的，他解析HTML和CSS，然后将他们构建成DOM树和渲染树就是这个线程负责的
  * 
  * JS引擎线程：
  *             这个线程就是负责执行JS的主线程，前面说的"JS是单线程的"就是指的这个线程。大名鼎鼎的Chrome V8引擎就是在这个线程运行的。
  *             需要注意的是，这个线程跟GUI线程是互斥的。互斥的原因是JS也可以操作DOM，如果JS线程和GUI线程同时操作DOM，结果就混乱了，不知道到底渲染哪个结果。
  *             这带来的后果就是如果JS长时间运行，GUI线程就不能执行，整个页面就感觉卡死了。
  *             所以我们最开始例子的while(true)这样长时间的同步代码在真正开发时是绝对不允许的。
  * 
  * 定时器线程：
  *             跟JS主线程根本不在同一个地方，所以“单线程的JS”能够实现异步
  * 
  * 事件触发线程：
  *             定时器线程其实只是一个计时的作用，他并不会真正等到执行时间到了就马上进行回调，真正执行这个回调的还是JS主线程。
  *             所以当时间到了定时器线程会将这个回调事件给到事件触发线程，然后事件触发线程将它加到事件队列里面去。
  *             最终JS主线程从事件队列取出这个回调执行。事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。
  * 
  * 异步HTTP请求线程：
  *             这个线程负责处理异步的ajax请求，当请求完成后，他也会通知事件触发线程，然后事件触发线程将这个事件放入事件队列给主线程执行。
  *             所以JS异步的实现靠的就是浏览器的多线程，当他遇到异步API时，就将这个任务交给对应的线程，
  *             当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，
  *             然后主线程从任务队列取出事件继续执行。这个流程我们多次提到了任务队列，这其实就是Event Loop
  */

/** 
 * Event Loop
 * 
 * 查看【event-loop.jpg】
 * 
 * (1) 主线程每次执行时，先看看要执行的是同步任务，还是异步的API
 * (2) 同步任务就继续执行，一直执行完
 * (3) 遇到异步API就将它交给对应的异步线程，自己继续执行同步任务
 * (4) 异步线程执行异步API，执行完后，将异步回调事件放入事件队列上
 * (5) 主线程手上的同步任务干完后就来事件队列看看有没有任务
 * (6) 主线程发现事件队列有任务，就取出里面的任务执行
 * (7) 主线程不断循环上述流程
 */
 
  
/** 
 * 定时器不准
 * 
 * Event Loop的这个流程里面其实还是隐藏了一些坑的，最典型的问题就是总是先执行同步任务，然后再执行事件队列里面的回调。
 * 这个特性就直接影响了定时器的执行，我们想想我们开始那个2秒定时器的执行流程：
 * (1) 主线程执行同步代码
 * (2) 遇到setTimeout，将它交给定时器线程
 * (3) 定时器线程开始计时，2秒到了通知事件触发线程
 * (4) 事件触发线程将定时器回调放入事件队列，异步流程到此结束
 * (5) 主线程如果有空，将定时器回调拿出来执行，如果没空这个回调就一直放在队列里
 */


/**
 * 引入微任务
 * 
 * 事件队列里面的事件还可以分两类：宏任务和微任务。微任务拥有更高的优先级，当事件循环遍历队列时，先检查微任务队列，
 * 如果里面有任务，就全部拿来执行，执行完之后再执行一个宏任务。执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。所以完整的流程图如下：
 * (1) 一个Event Loop可以有一个或多个事件队列，但是只有一个微任务队列
 * (2) 微任务队列全部执行完会重新渲染一次
 * (3) 每个宏任务执行完都会重新渲染一次
 * (4) requestAnimationFrame处于渲染阶段，不在微任务队列，也不在宏任务队列
 */

/**
 * setImmediate和setTimeout
 */
setTimeout(() => {
    setTimeout(() => {
      console.log('setTimeout');
    }, 0);
    window.setImmediate(() => {
      console.log('setImmediate');
    });
}, 0);
/** 
 * 运行结果：setImmediate
 *          setTimeout
 * 
 * 原因：
 *      外层是一个setTimeout，所以执行他的回调的时候已经在timers阶段了
 *      处理里面的setTimeout，因为本次循环的timers正在执行，所以他的回调其实加到了下个timers阶段
 *      处理里面的setImmediate，将它的回调加入check阶段的队列
 *      外层timers阶段执行完，进入pending callbacks，idle, prepare，poll，这几个队列都是空的，所以继续往下
 *      到了check阶段，发现了setImmediate的回调，拿出来执行
 *      然后是close callbacks，队列时空的，跳过
 *      又是timers阶段，执行我们的console
 */

setTimeout(() => {
    console.log('setTimeout');
}, 0);
  
setImmediate(() => {
    console.log('setImmediate');
});
/** 
 * 运行结果：setTimeout
 *          setImmediate
 * 
 * 原因：
 *      
 */

