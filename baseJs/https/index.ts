/**
 * https://mp.weixin.qq.com/s/VQRgk3hlYpHct1t8A4OY9w
 * 
 * 优化HTTPS的手段
 */

/**
 * - 由裸数据传输的 HTTP 协议转成加密数据传输的 HTTPS 协议，
 *    给应用数据套了个「保护伞」，提高安全性的同时也带来了性能消耗。
 * 
 * - 因为 HTTPS 相比 HTTP 协议多一个 TLS 协议握手过程，目的是为了通过非对称加密握手协商或者交换出对称加密密钥，
 *    这个过程最长可以花费掉 2 RTT，接着后续传输的应用数据都得使用对称加密密钥来加密/解密。
 * 
 * - 优化 HTTPS可以从如下方面入手：
 *   (1) 分析性能损耗
 *   (2) 硬件损耗
 *   (3) 软件优化
 *   (4) 会话复用
 *   (5) 协议优化
 *   (6) 证书优化
 */


/**
 * (1) 分析性能损耗
 * 
 * 产生性能消耗的两个环节：
 *    第一个环节， TLS 协议握手过程
 *    第二个环节，握手后的对称加密报文传输
 * 
 * 对于第二环节，现在主流的对称加密算法 AES、ChaCha20 性能都是不错的，
 *    而且一些 CPU 厂商还针对它们做了硬件级别的优化，因此这个环节的性能消耗可以说非常地小。
 * 
 * 第一个环节，TLS 协议握手过程不仅增加了网络延时（最长可以花费掉 2 RTT），而且握手过程中的一些步骤也会产生性能损耗：
 *    - 客户端验证证书时，会访问 CA 获取 CRL 或者 OCSP，目的是验证服务器的证书是否有被吊销
 *    - 双方计算 Pre-Master，也就是会话密钥
 *    - 对于 ECDHE 密钥协商算法，握手过程中会客户端和服务端都需要临时生成椭圆曲线公私钥
 */


/**
 * (2) 硬件优化
 * 
 * HTTPS 协议是计算密集型，而不是 I/O 密集型，所以可以买好的CPU。
 * 应该选择可以支持 AES-NI 特性的 CPU，因为这种款式的 CPU 能在指令级别优化了 AES 算法，这样便加速了数据的加解密传输过程。
 */ 


/**
 * (3) 协议优化
 * 
 * 协议的优化就是对「密钥交换过程」进行优化。
 * 
 * TLS 1.2 版本如果使用的是 RSA 密钥交换算法，那么需要 4 次握手，也就是要花费 2 RTT，才可以进行应用数据的传输。
 * 
 * 总之使用 RSA 密钥交换算法的 TLS 握手过程，不仅慢，而且安全性也不高。
 * 
 * 尽量选用 ECDHE 密钥交换算法，因为该算法由于支持「False Start」，它是“抢跑”的意思，客户端可以在 TLS 协议的第 3 次握手后，
 *    第 4 次握手前，发送加密的应用数据，以此将 TLS 握手的消息往返由 2 RTT 减少到 1 RTT，而且安全性也高
 * 
 * 
 * - TLS 升级
 * 直接把 TLS 1.2 升级成 TLS 1.3，TLS 1.3 大幅度简化了握手的步骤，完成 TLS 握手只要 1 RTT，而且安全性更高。
 * 
 * - TLS 1.3 的握手过程，如图【TLS 1.2-1.3.png】：
 * TLS 1.3 把 Hello 和公钥交换这两个消息合并成了一个消息，于是这样就减少到只需 1 RTT 就能完成 TLS 握手。
 * 如何合并的呢?
 * 
 * 
 * - TLS1.3 的三个主要改进目标：兼容、安全与性能
 * 
 * - TLS1.3总共有两层，分别是握手协议(handshake protocol)和记录协议(record protocol)，
 *    握手协议在记录协议的上层，记录协议是一个分层协议。其中握手协议中还包括了警告协议(alert protocol)
 * 
 * - TLS1.3握手协议主要分为三个流程
 *   (1) 密钥交换：选择TLS协议版本和加密的算法，并且协商算法所需的参数。这段是明文传输的
 *   (2) 服务器参数：建立其他握手协议参数，例如是否需要认证客户端，支持何种应用层协议等
 *   (3) 认证：对服务器进行认证(包括可选的客户端认证)并且提供密钥确认和验证握手完整性功能
 * 
 *   这三个阶段完成后就可以进行应用层数据传输
 */ 


/**
 * (4) 证书优化
 * 
 * 为了验证的服务器的身份，服务器会在 TSL 握手过程中，把自己的证书发给客户端，以此证明自己身份是可信的。
 * 
 * 对于证书的优化，可以有两个方向：
 *    - 一个是证书传输
 *    - 一个是证书验证
 * 
 * 证书传输优化
 *    要让证书更便于传输，那必然是减少证书的大小，这样可以节约带宽，也能减少客户端的运算量。所以，对于服务器的证书应该选择 椭圆曲线（ECDSA）证书，而不是 RSA 证书，
 *    因为在相同安全强度下， ECC 密钥长度比 RSA 短的多。
 * 
 * 证书验证优化
 *    客户端在验证证书时，是个复杂的过程，会走证书链逐级验证，验证的过程不仅需要「用 CA 公钥解密证书」以及「用签名算法验证证书的完整性」，
 *    而且为了知道证书是否被 CA 吊销，客户端有时还会再去访问 CA， 下载 CRL 或者 OCSP 数据，以此确认证书的有效性。
 *    这个访问过程是 HTTP 访问，因此又会产生一系列网络通信的开销，如 DNS 查询、建立连接、收发数据等。
 * 
 * CRL
 *    CRL 称为证书吊销列表，这个列表是由 CA 定期更新，列表内容都是被撤销信任的证书序号，如果服务器的证书在此列表，
 *    就认为证书已经失效，不在的话，则认为证书是有效的。
 * 
 *    但是 CRL 存在两个问题：
 *      (1) 实时性较差 
 *          由于 CRL 列表是由 CA 维护的，定期更新，如果一个证书刚被吊销后，客户端在更新 CRL 之前还是会信任这个证书。
 *      (2) 随着吊销证书的增多，列表会越来越大，下载的速度就会越慢
 * 
 * OCSP
 *    现在基本都是使用 OCSP ，名为在线证书状态协议。来查询证书的有效性，它的工作方式是向 CA 发送查询请求，让 CA 返回证书的有效状态。
 *    
 *    不必像 CRL 方式客户端需要下载大大的列表，还要从列表查询，同时因为可以实时查询每一张证书的有效性，解决了 CRL 的实时性问题。
 * 
 *    OCSP 需要向 CA 查询，因此也是要发生网络请求，如果网络状态不好，或者 CA 服务器繁忙，也会导致客户端在校验证书这一环节的延时变大。
 */ 


/**
 * (5) 会话复用
 * 
 * TLS 握手的目的就是为了协商出会话密钥，也就是对称加密密钥，那我们如果我们把首次 TLS 握手协商的对称加密密钥缓存起来，
 * 待下次需要建立 HTTPS 连接时，直接「复用」这个密钥，不就减少 TLS 握手的性能损耗了吗？
 * 
 * 这种方式就是会话复用，会话复用分两种：
 * - Session ID
 * - Session Ticket
 * 
 * Session ID
 *    Session ID 的工作原理是，客户端和服务器首次 TLS 握手连接后，双方会在内存缓存会话密钥，并用唯一的 Session ID 来标识，
 *    Session ID 和会话密钥相当于 key-value 的关系。
 *    
 *    当客户端再次连接时，hello 消息里会带上 Session ID，服务器收到后就会从内存找，如果找到就直接用该会话密钥恢复会话状态，
 *    跳过其余的过程，只用一个消息往返就可以建立安全通信。当然为了安全性，内存中的会话密钥会定期失效。
 * 
 *    但是它有两个缺点:
 *    (1) 服务器必须保持每一个客户端的会话密钥，随着客户端的增多，服务器的内存压力也会越大
 *    (2) 现在网站服务一般是由多台服务器通过负载均衡提供服务的，客户端再次连接不一定会命中上次访问过的服务器，
 *        于是还要走完整的 TLS 握手过程
 * 
 * Session Ticket
 *    为了解决 Session ID 的问题，就出现了 Session Ticket，服务器不再缓存每个客户端的会话密钥，
 *    而是把缓存的工作交给了客户端，类似于 HTTP 的 Cookie。
 * 
 *    客户端与服务器首次建立连接时，服务器会加密「会话密钥」作为 Ticket 发给客户端，交给客户端缓存该 Ticket。
 * 
 *    客户端再次连接服务器时，客户端会发送 Ticket，服务器解密后就可以获取上一次的会话密钥，
 *    然后验证有效期，如果没问题，就可以恢复会话了，开始加密通信。
 */ 



