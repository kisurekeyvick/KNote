/**
 * https://mp.weixin.qq.com/s/EGLnMO0b2-UiZ3K7qa8XRw
 * 
 * V8 引擎的垃圾回收
 * 
 * JavaScript之所以能在浏览器环境和NodeJS环境运行，都是因为有V8引擎在幕后保驾护航。
 * 从编译、内存分配、运行以及垃圾回收等整个过程，都离不开它。
 */
// https://github.com/sisterAn/JavaScript-Algorithms/issues/157
 function test() {  
    var a = 1;  
    var b = {};  
    var c = {a: a};  
    return c;
}

/**
 * 为什么要有垃圾回收
 * 
 * 在C语言和C++语言中，我们如果想要开辟一块堆内存的话，需要先计算需要内存的大小，然后自己通过malloc函数去手动分配，
 * 在用完之后，还要时刻记得用free函数去清理释放，否则这块内存就会被永久占用，造成内存泄露。
 * 
 * 但是我们在写JavaScript的时候，却没有这个过程，因为人家已经替我们封装好了，V8引擎会根据你当前定义对象的大小去自动申请分配内存。
 * 
 * 垃圾回收的好处是不需要我们去管理内存，把更多的精力放在实现复杂应用上，但坏处也来自于此，
 * 不用管理了，就有可能在写代码的时候不注意，造成循环引用等情况，导致内存泄露。
 */

/**
 * 内存结构分配
 * 
 * 由于V8最开始就是为JavaScript在浏览器执行而打造的，不太可能遇到使用大量内存的场景，所以它可以申请的最大内存就没有设置太大，
 * 在64位系统下大约为1.4GB，在32位系统下大约为700MB。
 * 
 * 在NodeJS环境中，我们可以通过**process.memoryUsage()**来查看内存分配。
 * 
 * 如果说想要扩大Node可用的内存空间，可以使用Buffer等堆外内存内存。
 */
// 在node中输入 process.memoryUsage()
const memoryUsage = {
    // 所有内存占用，包括指令区和堆栈
    rss: '',
    // V8引擎可以分配的最大堆内存，包含下面的 heapUsed
    heapTotal: '',
    // V8引擎已经分配使用的堆内存
    heapUsed: '',
    // V8管理C++对象绑定到JavaScript对象上的内存
    external: ''
}

// Node的整体架构图:【Node的整体架构图.png】
/**
    Node Standard Library: 是我们每天都在用的标准库，如Http, Buffer 模块

    Node Bindings: 是沟通JS 和 C++的桥梁，封装V8和Libuv的细节，向上层提供基础API服务

    第三层是支撑 Node.js 运行的关键，由 C/C++ 实现：
    1. V8 是Google开发的JavaScript引擎，提供JavaScript运行环境，可以说它就是 Node.js 的发动机
    2. Libuv 是专门为Node.js开发的一个封装库，提供跨平台的异步I/O能力
    3. C-ares：提供了异步处理 DNS 相关的能力
    4. http_parser、OpenSSL、zlib 等：提供包括 http 解析、SSL、数据压缩等其他的能力
 */

/**
 * 垃圾回收机制
 * 
 * (1) 如何判断是否可以回收
 * - 标记清除
 *  当变量进入环境时，将这个变量标记为“进入环境”。
 * 逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。
 * 而当变量离开环境时，则将其标记为“离开环境”。
 * 
 *  可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境，
 * 或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。
 * 
 * 采取策略：
 *  I: 垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
 *  II: 它会去掉运行环境中的变量以及被环境中变量所引用的变量的标记。
 *  III: 依然有标记的变量就被视为准备删除的变量，原因是在运行环境中已经无法访问到这些变量了。
 *  V: 最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。
 * 
 * 目前，IE、Firefox、Opera、Chrome和Safari的JavaScript实现使用的都是标记清除式的垃圾回收策略（或类似的策略），只不过垃圾收集的时间间隔互有不同。
 * 
 * - 引用计数
 * 含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。
 * 
 * 如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量改变了引用对象，则该值引用次数减1。
 * 
 * 当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。
 * 
 * 最早使用引用计数策略的浏览器，但很快它就遇到了一个严重的问题：循环引用。
 * 
 * 
 */ 


    