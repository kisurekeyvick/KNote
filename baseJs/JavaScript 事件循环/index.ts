/**
 * https://mp.weixin.qq.com/s/pmduRv-1JKU7tq9vkBTMXg
 * 
 * JavaScript 事件循环：从起源到浏览器再到 Node.js
 * 
 * 从三个角度来研究 JavaScript 的事件循环:
 * (1) 为什么是事件循环
 * (2) 事件循环是什么
 * (3) 浏览器与 Node.js 的事件循环差异
 */

/**
 * 事件循环是什么
 * 
 * 各种浏览器事件同时触发时，肯定有一个先来后到的排队问题。决定这些事件如何排队触发的机制，就是事件循环。
 * 这个排队行为以 JavaScript 开发者的角度来看，主要是分成两个队列：
 * (1) JavaScript 外部的队列。
 *      外部的队列主要是浏览器协调的各类事件的队列，标准文件中称之为 Task Queue。下文中为了方便理解统一称为外部队列。
 * (2) JavaScript 内部的队列。
 *      这部分主要是 JavaScript 内部执行的任务队列，标准中称之为 Microtask Queue。下文中为了方便理解统一称为内部队列。
 * 
 * 
 * 值得注意的是，虽然为了好理解我们管这个叫队列 (Queue)，但是本质上是有序集合 (Set)，因为传统的队列都是先进先出（FIFO）的。
 * 而这里的队列则不然，排到最前面但是没有满足条件也是不会执行的
 * （比如外部队列里只有一个 setTimeout 的定时任务，但是时间还没有到，没有满足条件也不会把他出列来执行）。
 */

/**
 * 外部队列
 * 
 * 外部队列，顾名思义就是 JavaScript 外部的事件的队列，这里我们可以先列举一下浏览器中这些外部事件源（Task Source），他们主要有：
 * (1) DOM 操作 (页面渲染)
 * (2) 用户交互 (鼠标、键盘)
 * (3) 网络请求 (Ajax 等)
 * (4) History API 操作
 * (5) 定时器 (setTimeout 等)
 * 
 * 这些外部的事件源可能很多，为了方便浏览器厂商优化，HTML 标准中明确指出一个事件循环由一个或多个外部队列，而每一个外部事件源都有一个对应的外部队列。
 * 不同事件源的队列可以有不同的优先级
 * （例如在网络事件和用户交互之间，浏览器可以优先处理鼠标行为，从而让用户感觉更加流程）。
 */

/**
 * 内部队列
 * 
 * 内部队列，即 JavaScript 语言内部的事件队列，在 HTML 标准中，并没有明确规定这个队列的事件源，通常认为有以下几种：
 * (1) Promise.then 和 Promise.catch
 * (2) MutationObserver 
 */


/**
 * 处理模型
 * 
 * 处理过程：
 * (1) 从外部队列中取出一个可执行任务，如果有则执行，没有下一步
 * (2) 挨个取出内部队列中的所有任务执行，执行完毕或没有则下一步
 * (3) 浏览器渲染
 * 
 * 
 */



