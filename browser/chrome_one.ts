/**
 * Chrome架构：仅仅打开了1个页面，为什么有4个进程？
 */

/**
 * 线程
 * 
 * A = 1+2
 * B = 20/5
 * C = 7*8
 * 
    在编写代码的时候，我们可以把这个过程拆分为四个任务：
    任务 1 是计算 A=1+2；
    任务 2 是计算 B=20/5；
    任务 3 是计算 C=7*8；
    任务 4 是显示最后计算的结果；

    单线程处理：分四步按照顺序分别执行这四个任务
    多线程：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。
 */

/**
 * 线程 VS 进程
 * 
 * 多线程可以并行处理任务，但是线程是不能单独存在的，它是由进程来启动和管理的。
 * 
 * 一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，
 * 用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫进程。   如图【进程.png】
 * 
 * 从图中可以看到，线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率
 * 
 * 进程和线程之间的关系有以下 4 个特点：
 * (1) 进程中的任意一线程执行出错，都会导致整个进程的崩溃
 * (2) 线程之间共享进程中的数据
 * (3) 当一个进程关闭之后，操作系统会回收进程所占用的内存
 * (4) 进程之间的内容相互隔离
 */

/**
 * 单进程浏览器不稳定、不流畅和不安全的一个主要因素
 * 
 * 
 * 问题 1：不稳定
 * 早期浏览器需要借助于插件来实现诸如 Web 视频、Web 游戏等各种强大的功能，但是插件是最容易出问题的模块，
 * 并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。
 * 
 * 除了插件之外，渲染引擎模块也是不稳定的，通常一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。
 * 和插件一样，渲染引擎的崩溃也会导致整个浏览器的崩溃
 * 
 * 
 * 问题 2：不流畅
    function freeze() { 
        while (1) { 
            console.log("freeze"); 
        }
    }
    
    freeze();
 *  
 * 上面代码如果在单进程浏览器中运行，因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，
 * 这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有的页面都运行在该线程中，
 * 所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。
 * 
 * 除了上述脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，
 * 运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。
 * 
 * 
 * 问题 3：不安全
 * 这里依然可以从插件和页面脚本两个方面来解释该原因。
 * 
 * 插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。
 * 如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。
 * 
 * 至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。
 */


/**
 * 目前多进程架构
 * 
 * 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程。
 * 
 * 浏览器进程：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。
 * 渲染进程：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，
 *          排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。
 *          出于安全考虑，渲染进程都是运行在沙箱模式下。
 * GPU 进程：而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。
 *          最后，Chrome 在其多进程架构上也引入了 GPU 进程。
 * 网络进程：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。
 * 插件进程：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。
 */ 


/**
 * 仅仅打开了 1 个页面，为什么有 4 个进程？
 * 
 * 因为打开 1 个页面至少需要 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程，共 4 个；
 * 如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。
 */


/**
 * 不过凡事都有两面性，虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：
 * 
 * 更高的资源占用：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源
 * 更复杂的体系架构：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了
 */


/**
 * 即使是如今的多进程架构，我偶尔还会碰到一些由于单个页面卡死最终崩溃导致所有页面崩溃的情况，请问这是什么原因呢?
 * 
 * 通常情况下是一个页面使用一个进程，但是，有一种情况，叫"同一站点(same-site)"，具体地讲，
 * 我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者http://），
 * 还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：
 * https://time.geekbang.org
 * https://www.geekbang.org
 * https://www.geekbang.org:8080
 * 
 * 都是属于同一站点，因为它们的协议都是https，而根域名也都是geekbang.org。
 * 你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事就行了。
 * 
 * Chrome的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，
 * 那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。
 * 
 * 直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。
 * 所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。
 * 
 * 为什么要让他们跑在一个进程里面呢？
 * 因为在一个渲染进程里面，他们就会共享JS的执行环境，也就是说A页面可以直接在B页面中执行脚本。因为是同一家的站点，所以是有这个需求的。
 */ 

